import unittest
import ../../variant_dsl
import ../../pattern_matching

## Comprehensive tests for enum discriminators automatically generated by variant DSL
##
## The variant DSL generates:
## - Enum type: {TypeName}Kind = enum { {prefix}k{Constructor1}, {prefix}k{Constructor2}, ... }
## - Discriminator field: kind: {TypeName}Kind
##
## Example: variant Shape -> ShapeKind = enum { skCircle, skRectangle }
##          where prefix = first letter of type name lowercased

suite "Variant Enum Discriminators - Basic Discriminator Access":

  test "direct discriminator field access via .kind":
    variant Shape:
      Circle(radius: float)
      Rectangle(w: float, h: float)

    let circle = Shape.Circle(5.0)
    let rectangle = Shape.Rectangle(10.0, 20.0)

    # Direct .kind field access
    check circle.kind == skCircle
    check rectangle.kind == skRectangle

  test "discriminator access with zero-parameter constructors":
    variant Signal:
      Start()
      Stop()
      Pause()

    let start = Signal.Start()
    let stop = Signal.Stop()
    let pause = Signal.Pause()

    check start.kind == skStart
    check stop.kind == skStop
    check pause.kind == skPause

  test "discriminator access with mixed constructors":
    variant Message:
      Empty()
      Text(content: string)
      Data(bytes: int, checksum: int)

    let empty = Message.Empty()
    let text = Message.Text("hello")
    let data = Message.Data(1024, 0xABCD)

    check empty.kind == mkEmpty
    check text.kind == mkText
    check data.kind == mkData

suite "Variant Enum Discriminators - Pattern Matching with Discriminators":

  test "discriminator matching in guards":
    variant Vehicle:
      Car(carWheels: int)
      Bike(bikeWheels: int)
      Truck(truckWheels: int, capacity: int)

    let car = Vehicle.Car(4)
    let bike = Vehicle.Bike(2)
    let truck = Vehicle.Truck(6, 5000)

    # Test discriminator in guard conditions
    let carResult = match car:
      v and v.kind == vkCar: "It's a car"
      v and v.kind == vkBike: "It's a bike"
      v and v.kind == vkTruck: "It's a truck"
      _: "Unknown"

    let bikeResult = match bike:
      v and v.kind == vkCar: "It's a car"
      v and v.kind == vkBike: "It's a bike"
      v and v.kind == vkTruck: "It's a truck"
      _: "Unknown"

    check carResult == "It's a car"
    check bikeResult == "It's a bike"

  test "discriminator guards with field access":
    variant Token:
      Number(value: int)
      String(text: string)
      Symbol(char: char)

    let number = Token.Number(42)
    let str = Token.String("hello")

    # Combine discriminator check with field access
    let numResult = match number:
      t and t.kind == tkNumber and t.value > 10: "Large number"
      t and t.kind == tkNumber: "Small number"
      t and t.kind == tkString: "String token"
      _: "Other"

    let strResult = match str:
      t and t.kind == tkNumber: "Number token"
      t and t.kind == tkString and t.text.len > 3: "Long string"
      t and t.kind == tkString: "Short string"
      _: "Other"

    check numResult == "Large number"
    check strResult == "Long string"

  test "discriminator in complex guard expressions":
    variant Status:
      Idle()
      Running(progress: int)
      Failed(errorCode: int)

    let running = Status.Running(75)
    let failed = Status.Failed(404)

    # Complex guards with discriminator
    let runningResult = match running:
      s and (s.kind == skRunning) and s.progress > 50 and s.progress < 100: "Almost done"
      s and (s.kind == skRunning) and s.progress >= 100: "Complete"
      s and s.kind == skRunning: "In progress"
      s and s.kind == skFailed: "Error occurred"
      _: "Idle"

    let failedResult = match failed:
      s and s.kind == skFailed and s.errorCode >= 400 and s.errorCode < 500: "Client error"
      s and s.kind == skFailed and s.errorCode >= 500: "Server error"
      s and s.kind == skRunning: "Running"
      _: "Other"

    check runningResult == "Almost done"
    check failedResult == "Client error"

suite "Variant Enum Discriminators - OR Patterns with Discriminators":

  test "OR patterns matching multiple discriminator values":
    variant Color:
      Red()
      Green()
      Blue()
      Yellow()

    let red = Color.Red()
    let green = Color.Green()
    let blue = Color.Blue()
    let yellow = Color.Yellow()

    # OR patterns with discriminator checks
    let warmResult = match red:
      c and (c.kind == ckRed or c.kind == ckYellow): "Warm color"
      c and (c.kind == ckBlue or c.kind == ckGreen): "Cool color"
      _: "Unknown"

    let coolResult = match blue:
      c and (c.kind == ckRed or c.kind == ckYellow): "Warm color"
      c and (c.kind == ckBlue or c.kind == ckGreen): "Cool color"
      _: "Unknown"

    check warmResult == "Warm color"
    check coolResult == "Cool color"

  test "OR patterns with discriminator and constructor patterns combined":
    variant Outcome:
      Success(value: string)
      Warning(message: string)
      Error(code: int)

    let success = Outcome.Success("done")
    let warning = Outcome.Warning("deprecated")
    let error = Outcome.Error(500)

    # Match success OR warning (both have string fields)
    let okResult = match success:
      Outcome.Success(v): "Success: " & v
      Outcome.Warning(m): "Warning: " & m
      Outcome.Error(c): "Error code: " & $c

    let warnResult = match warning:
      Outcome.Success(v): "Success: " & v
      Outcome.Warning(m): "Warning: " & m
      Outcome.Error(c): "Error code: " & $c

    check okResult == "Success: done"
    check warnResult == "Warning: deprecated"

suite "Variant Enum Discriminators - Exhaustiveness Checking":

  test "exhaustive pattern matching covers all enum values":
    variant Direction:
      North()
      South()
      East()
      West()

    let north = Direction.North()

    # Exhaustive match - all discriminator values covered
    let result = match north:
      Direction.North(): "Going north"
      Direction.South(): "Going south"
      Direction.East(): "Going east"
      Direction.West(): "Going west"

    check result == "Going north"

  test "exhaustive with wildcard covers remaining discriminators":
    variant Priority:
      Critical()
      High()
      Medium()
      Low()

    let critical = Priority.Critical()
    let low = Priority.Low()

    # Partial match with wildcard
    let criticalResult = match critical:
      Priority.Critical(): "URGENT!"
      _: "Not critical"

    let lowResult = match low:
      Priority.Critical(): "URGENT!"
      _: "Not critical"

    check criticalResult == "URGENT!"
    check lowResult == "Not critical"

  test "exhaustive checking detects missing discriminator cases":
    template shouldNotCompile(code: untyped): bool =
      not compiles(code)

    variant Level:
      Easy()
      Medium()
      Hard()

    # Should not compile - missing Hard() case
    check shouldNotCompile (
      let lvl = Level.Easy()
      let result = match lvl:
        Level.Easy(): "easy"
        Level.Medium(): "medium"
        # Hard() missing!
    )

suite "Variant Enum Discriminators - Discriminator Comparison in Guards":

  test "discriminator equality comparison":
    variant State:
      Pending()
      Active(id: int)
      Complete(output: string)

    let pending = State.Pending()
    let active = State.Active(123)

    # Discriminator equality in guards
    let pendingMatch = match pending:
      s and s.kind == skPending: "Waiting"
      s and s.kind == skActive: "Processing: " & $s.id
      s and s.kind == skComplete: "Done: " & s.output
      _: "Unknown"

    let activeMatch = match active:
      s and s.kind == skPending: "Waiting"
      s and s.kind == skActive: "Processing: " & $s.id
      s and s.kind == skComplete: "Done: " & s.output
      _: "Unknown"

    check pendingMatch == "Waiting"
    check activeMatch == "Processing: 123"

  test "discriminator inequality comparison":
    variant Event:
      Click()
      KeyPress(key: char)
      MouseMove(x: int, y: int)

    let click = Event.Click()
    let keyPress = Event.KeyPress('a')

    # Not-equal discriminator checks
    let clickResult = match click:
      Event.Click @ e and e.kind != ekKeyPress and e.kind != ekMouseMove: "Click event"
      Event.KeyPress @ e: "Key event"
      Event.MouseMove @ e: "Mouse move"

    let keyResult = match keyPress:
      Event.Click @ e: "Click event"
      Event.KeyPress @ e and e.kind == ekKeyPress: "Key event: " & $e.key
      Event.MouseMove @ e: "Mouse move"

    check clickResult == "Click event"
    check keyResult == "Key event: a"

  test "discriminator range comparison (enum ordering)":
    variant Grade:
      A()
      B()
      C()
      D()
      F()

    let gradeA = Grade.A()
    let gradeC = Grade.C()
    let gradeF = Grade.F()

    # Compare enum discriminators using ordering
    let aResult = match gradeA:
      g and g.kind <= gkB: "Excellent"
      g and g.kind == gkC: "Average"
      g and g.kind >= gkD: "Poor"
      _: "Unknown"

    let cResult = match gradeC:
      g and g.kind <= gkB: "Excellent"
      g and g.kind == gkC: "Average"
      g and g.kind >= gkD: "Poor"
      _: "Unknown"

    let fResult = match gradeF:
      g and g.kind <= gkB: "Excellent"
      g and g.kind == gkC: "Average"
      g and g.kind >= gkD: "Poor"
      _: "Unknown"

    check aResult == "Excellent"
    check cResult == "Average"
    check fResult == "Poor"

suite "Variant Enum Discriminators - Multiple Variants with Different Enums":

  test "different variant types have different enum discriminators":
    variant Animal:
      Dog(dogName: string)
      Cat(catName: string)

    variant Plant:
      Tree(height: float)
      Flower(color: string)

    let dog = Animal.Dog("Rex")
    let tree = Plant.Tree(10.5)

    # Each variant has its own enum type
    check dog.kind == akDog
    check tree.kind == pkTree

    # Pattern match works independently
    let animalResult = match dog:
      Animal.Dog(n): "Dog: " & n
      Animal.Cat(n): "Cat: " & n

    let plantResult = match tree:
      Plant.Tree(h): "Tree: " & $h & "m"
      Plant.Flower(c): "Flower: " & c

    check animalResult == "Dog: Rex"
    check plantResult == "Tree: 10.5m"

  test "discriminators from different variants don't conflict":
    variant TypeA:
      First(x: int)
      Second(y: int)

    variant TypeB:
      First(z: int)
      Second(w: int)

    let a = TypeA.First(10)
    let b = TypeB.First(20)

    # Same constructor names but different discriminator enums
    check a.kind == tkFirst  # TypeAKind.tkFirst
    check b.kind == tkFirst  # TypeBKind.tkFirst

    # Each maintains type safety
    let aResult = match a:
      TypeA.First(val): val * 2
      TypeA.Second(val): val * 3

    let bResult = match b:
      TypeB.First(val): val + 100
      TypeB.Second(val): val + 200

    check aResult == 20
    check bResult == 120

suite "Variant Enum Discriminators - Nested Variants with Nested Discriminators":

  test "nested variants maintain separate discriminator fields":
    variant Inner:
      Value(n: int)
      Empty()

    variant Outer:
      Container(inner: Inner)
      Null()

    let innerValue = Inner.Value(42)
    let outerContainer = Outer.Container(innerValue)

    # Access nested discriminators
    let result = match outerContainer:
      Outer.Container(i):
        match i:
          Inner.Value(n): "Inner value: " & $n
          Inner.Empty(): "Inner empty"
      Outer.Null(): "Outer null"

    check result == "Inner value: 42"

  test "deep nesting with multiple discriminator levels":
    variant Level1:
      L1Data(value: int)
      L1Empty()

    variant Level2:
      L2Wrapper(data: Level1)
      L2Null()

    variant Level3:
      L3Container(wrapped: Level2)
      L3End()

    let l1 = Level1.L1Data(100)
    let l2 = Level2.L2Wrapper(l1)
    let l3 = Level3.L3Container(l2)

    # Navigate through discriminators
    let result = match l3:
      Level3.L3Container(w):
        match w:
          Level2.L2Wrapper(d):
            match d:
              Level1.L1Data(v): "Value at depth 3: " & $v
              Level1.L1Empty(): "Empty at depth 3"
          Level2.L2Null(): "Null at depth 2"
      Level3.L3End(): "End"

    check result == "Value at depth 3: 100"

  test "nested discriminator guards with field access":
    variant Option:
      Some(value: int)
      None()

    variant Outcome:
      Ok(opt: Option)
      Err(message: string)

    let someValue = Option.Some(42)
    let ok = Outcome.Ok(someValue)

    # Check discriminators at multiple levels
    let result = match ok:
      Outcome.Ok @ r and r.kind == okOk:
        match r.opt:
          Option.Some @ o and o.kind == okSome and o.value > 40: "Large value: " & $o.value
          Option.Some @ o and o.kind == okSome: "Small value: " & $o.value
          Option.None @ o and o.kind == okNone: "No value"
      Outcome.Err @ r and r.kind == okErr: "Error: " & r.message
      _: "Unknown"

    check result == "Large value: 42"

suite "Variant Enum Discriminators - Edge Cases":

  test "single constructor variant has single enum value":
    variant Singleton:
      Only(data: string)

    let single = Singleton.Only("unique")

    check single.kind == skOnly

    let result = match single:
      Singleton.Only(d): d

    check result == "unique"

  test "large number of constructors with many enum values":
    variant ManyOptions:
      Opt1()
      Opt2()
      Opt3()
      Opt4()
      Opt5()
      Opt6()
      Opt7()
      Opt8()
      Opt9()
      Opt10()

    let opt1 = ManyOptions.Opt1()
    let opt5 = ManyOptions.Opt5()
    let opt10 = ManyOptions.Opt10()

    check opt1.kind == mkOpt1
    check opt5.kind == mkOpt5
    check opt10.kind == mkOpt10

    # Pattern match works with many cases
    let result = match opt5:
      ManyOptions.Opt1(): "1"
      ManyOptions.Opt2(): "2"
      ManyOptions.Opt3(): "3"
      ManyOptions.Opt4(): "4"
      ManyOptions.Opt5(): "5"
      ManyOptions.Opt6(): "6"
      ManyOptions.Opt7(): "7"
      ManyOptions.Opt8(): "8"
      ManyOptions.Opt9(): "9"
      ManyOptions.Opt10(): "10"

    check result == "5"

  test "discriminator with complex field types":
    variant Complex:
      SeqData(items: seq[int])
      TupleData(pair: (int, string))
      RefData(reference: ref int)

    let seqData = Complex.SeqData(@[1, 2, 3])
    let tupleData = Complex.TupleData((42, "answer"))

    check seqData.kind == ckSeqData
    check tupleData.kind == ckTupleData

    let seqResult = match seqData:
      c and c.kind == ckSeqData: $c.items.len
      c and c.kind == ckTupleData: $c.pair[0]
      _: "other"

    let tupleResult = match tupleData:
      c and c.kind == ckSeqData: $c.items.len
      c and c.kind == ckTupleData: c.pair[1]
      _: "other"

    check seqResult == "3"
    check tupleResult == "answer"
