## Comprehensive Negative Tests: Deque and LinkedList Pattern Errors
##
## This test suite validates that Deque and LinkedList patterns with errors cause
## compilation failures with helpful error messages from the pattern validation module.
##
## Test Coverage:
## 1. Tuple patterns on Deque (nnkPar, nnkTupleConstr)
## 2. Object patterns on Deque (nnkObjConstr, nnkCall)
## 3. Table patterns on Deque (nnkTableConstr)
## 4. Set patterns on Deque (nnkCurly)
## 5. Tuple patterns on LinkedList variants
## 6. Object patterns on LinkedList variants
## 7. Table patterns on LinkedList variants
## 8. Set patterns on LinkedList variants
## 9. Element type mismatches in sequence patterns
##
## Tests validate error messages generated by:
## - `validateDequePattern` in pattern_validation.nim (lines 1521-1551)
## - `validateLinkedListPattern` in pattern_validation.nim (lines 1553-1583)
##
## Expected behavior: Deque and LinkedList types ONLY support:
## - Sequence patterns: [a, b, c]
## - Variable bindings: x, _
## All other pattern types should fail compilation

import unittest
import ../../pattern_matching
import ../helper/ccheck
import std/deques
import std/lists
import std/tables

# ============================================================================
# SUITE 1: Deque - Tuple Pattern Errors (nnkPar, nnkTupleConstr)
# ============================================================================

suite "Negative Tests: Deque Tuple Pattern Errors":

  test "tuple pattern (a, b) on Deque[int] should not compile":
    check shouldNotCompile (
      var dq = initDeque[int]()
      dq.addLast(1)
      dq.addLast(2)
      match dq:
        (a, b): a + b  # Wrong: should use [a, b]
        _: 0
    )

  test "nested tuple pattern ((a, b), c) on Deque[tuple] should not compile":
    check shouldNotCompile (
      var dq = initDeque[(int, int)]()
      dq.addLast((1, 2))
      dq.addLast((3, 4))
      match dq:
        ((a, b), (c, d)): a + b + c + d  # Wrong: should use [(a1, b1), (a2, b2)]
        _: 0
    )

  test "3-element tuple pattern (x, y, z) on Deque[int] should not compile":
    check shouldNotCompile (
      var dq = initDeque[int]()
      dq.addLast(10)
      dq.addLast(20)
      dq.addLast(30)
      match dq:
        (x, y, z): x + y + z  # Wrong: should use [x, y, z]
        _: 0
    )

  test "empty tuple pattern () on Deque[int] should not compile":
    check shouldNotCompile (
      var dq = initDeque[int]()
      match dq:
        (): 42  # Wrong: should use [] or _
        _: 0
    )

  test "single element tuple (x,) on Deque[int] should not compile":
    check shouldNotCompile (
      var dq = initDeque[int]()
      dq.addLast(100)
      match dq:
        (x,): x  # Wrong: should use [x]
        _: 0
    )

# ============================================================================
# SUITE 2: Deque - Object Pattern Errors (nnkCall, nnkObjConstr)
# ============================================================================

suite "Negative Tests: Deque Object Pattern Errors":

  test "object pattern Point(x, y) on Deque[Point] should not compile":
    type Point = object
      x, y: int
    check shouldNotCompile (
      var dq = initDeque[Point]()
      dq.addLast(Point(x: 1, y: 2))
      match dq:
        Point(x, y): x + y  # Wrong: should use [Point(x, y)]
        _: 0
    )

  test "object call pattern User(name) on Deque[User] should not compile":
    type User = object
      name: string
      age: int
    check shouldNotCompile (
      var dq = initDeque[User]()
      dq.addLast(User(name: "Alice", age: 30))
      match dq:
        User(name): name  # Wrong: should use [User(name)]
        _: ""
    )

  test "nested object pattern Data(Point(x, y)) on Deque[Data] should not compile":
    type
      Point = object
        x, y: int
      Data = object
        point: Point
    check shouldNotCompile (
      var dq = initDeque[Data]()
      dq.addLast(Data(point: Point(x: 5, y: 10)))
      match dq:
        Data(Point(x, y)): x + y  # Wrong: should use [Data(Point(x, y))]
        _: 0
    )

  test "named field object pattern Person(name=n, age=a) on Deque[Person] should not compile":
    type Person = object
      name: string
      age: int
    check shouldNotCompile (
      var dq = initDeque[Person]()
      dq.addLast(Person(name: "Bob", age: 25))
      match dq:
        Person(name=n, age=a): n & " is " & $a  # Wrong: should use [Person(name=n, age=a)]
        _: ""
    )

# ============================================================================
# SUITE 3: Deque - Table Pattern Errors (nnkTableConstr)
# ============================================================================

suite "Negative Tests: Deque Table Pattern Errors":

  test "table pattern {key: value} on Deque[Table] should not compile":
    check shouldNotCompile (
      var dq = initDeque[Table[string, int]]()
      dq.addLast({"a": 1, "b": 2}.toTable)
      match dq:
        {"a": x, "b": y}: x + y  # Wrong: should use [{"a": x, "b": y}]
        _: 0
    )

  test "simple table pattern {k: v} on Deque[int] should not compile":
    check shouldNotCompile (
      var dq = initDeque[int]()
      dq.addLast(42)
      match dq:
        {"key": value}: value  # Wrong: type mismatch and should use []
        _: 0
    )

  test "spread table pattern {key: x, **rest} on Deque[Table] should not compile":
    check shouldNotCompile (
      var dq = initDeque[Table[string, string]]()
      dq.addLast({"name": "Alice", "city": "NYC"}.toTable)
      match dq:
        {"name": n, **rest}: n  # Wrong: should use [{"name": n, **rest}]
        _: ""
    )

# ============================================================================
# SUITE 4: Deque - Set Pattern Errors (nnkCurly)
# ============================================================================

suite "Negative Tests: Deque Set Pattern Errors":

  test "set pattern {Red, Blue} on Deque[set[Color]] should not compile":
    type Color = enum
      Red, Green, Blue
    check shouldNotCompile (
      var dq = initDeque[set[Color]]()
      dq.addLast({Red, Blue})
      match dq:
        {Red, Blue}: "red and blue"  # Wrong: should use [{Red, Blue}]
        _: ""
    )

  test "single element set pattern {x} on Deque[set[int]] should not compile":
    check shouldNotCompile (
      var dq = initDeque[set[int8]]()
      dq.addLast({1i8, 2i8, 3i8})
      match dq:
        {1i8}: "has one"  # Wrong: should use [{1i8}]
        _: ""
    )

  test "empty set pattern {} on Deque[set[char]] should not compile":
    check shouldNotCompile (
      var dq = initDeque[set[char]]()
      dq.addLast({'a', 'b'})
      match dq:
        {}: "empty"  # Wrong: should use [{}] or check for empty with guards
        _: ""
    )

# ============================================================================
# SUITE 5: LinkedList - Tuple Pattern Errors (All 4 Variants)
# ============================================================================

suite "Negative Tests: SinglyLinkedList Tuple Pattern Errors":

  test "tuple pattern (a, b) on SinglyLinkedList[int] should not compile":
    check shouldNotCompile (
      var list = initSinglyLinkedList[int]()
      list.add(1)
      list.add(2)
      match list:
        (a, b): a + b  # Wrong: should use [a, b]
        _: 0
    )

  test "3-element tuple pattern (x, y, z) on SinglyLinkedList[string] should not compile":
    check shouldNotCompile (
      var list = initSinglyLinkedList[string]()
      list.add("a")
      list.add("b")
      list.add("c")
      match list:
        (x, y, z): x & y & z  # Wrong: should use [x, y, z]
        _: ""
    )

suite "Negative Tests: DoublyLinkedList Tuple Pattern Errors":

  test "tuple pattern (first, second) on DoublyLinkedList[int] should not compile":
    check shouldNotCompile (
      var list = initDoublyLinkedList[int]()
      list.add(10)
      list.add(20)
      match list:
        (first, second): first + second  # Wrong: should use [first, second]
        _: 0
    )

  test "nested tuple pattern ((a, b), c) on DoublyLinkedList[tuple] should not compile":
    check shouldNotCompile (
      var list = initDoublyLinkedList[(int, int)]()
      list.add((1, 2))
      list.add((3, 4))
      match list:
        ((a, b), (c, d)): a + b + c + d  # Wrong: should use [(a, b), (c, d)]
        _: 0
    )

suite "Negative Tests: SinglyLinkedRing Tuple Pattern Errors":

  test "tuple pattern (x, y) on SinglyLinkedRing[float] should not compile":
    check shouldNotCompile (
      var ring = initSinglyLinkedRing[float]()
      ring.add(1.5)
      ring.add(2.5)
      match ring:
        (x, y): x + y  # Wrong: should use [x, y]
        _: 0.0
    )

  test "4-element tuple pattern (a, b, c, d) on SinglyLinkedRing[int] should not compile":
    check shouldNotCompile (
      var ring = initSinglyLinkedRing[int]()
      ring.add(1)
      ring.add(2)
      ring.add(3)
      ring.add(4)
      match ring:
        (a, b, c, d): a + b + c + d  # Wrong: should use [a, b, c, d]
        _: 0
    )

suite "Negative Tests: DoublyLinkedRing Tuple Pattern Errors":

  test "tuple pattern (head, tail) on DoublyLinkedRing[string] should not compile":
    check shouldNotCompile (
      var ring = initDoublyLinkedRing[string]()
      ring.add("first")
      ring.add("second")
      match ring:
        (head, tail): head & tail  # Wrong: should use [head, tail]
        _: ""
    )

  test "empty tuple pattern () on DoublyLinkedRing[int] should not compile":
    check shouldNotCompile (
      var ring = initDoublyLinkedRing[int]()
      match ring:
        (): 99  # Wrong: should use [] or _
        _: 0
    )

# ============================================================================
# SUITE 6: LinkedList - Object Pattern Errors (All 4 Variants)
# ============================================================================

suite "Negative Tests: SinglyLinkedList Object Pattern Errors":

  test "object pattern Point(x, y) on SinglyLinkedList[Point] should not compile":
    type Point = object
      x, y: int
    check shouldNotCompile (
      var list = initSinglyLinkedList[Point]()
      list.add(Point(x: 5, y: 10))
      match list:
        Point(x, y): x + y  # Wrong: should use [Point(x, y)]
        _: 0
    )

  test "object call pattern Node(val) on SinglyLinkedList[Node] should not compile":
    type Node = object
      val: int
    check shouldNotCompile (
      var list = initSinglyLinkedList[Node]()
      list.add(Node(val: 42))
      match list:
        Node(val): val  # Wrong: should use [Node(val)]
        _: 0
    )

suite "Negative Tests: DoublyLinkedList Object Pattern Errors":

  test "object pattern User(name, age) on DoublyLinkedList[User] should not compile":
    type User = object
      name: string
      age: int
    check shouldNotCompile (
      var list = initDoublyLinkedList[User]()
      list.add(User(name: "Charlie", age: 35))
      match list:
        User(name, age): name & " " & $age  # Wrong: should use [User(name, age)]
        _: ""
    )

  test "named field object pattern Data(value=v) on DoublyLinkedList[Data] should not compile":
    type Data = object
      value: float
    check shouldNotCompile (
      var list = initDoublyLinkedList[Data]()
      list.add(Data(value: 3.14))
      match list:
        Data(value=v): v  # Wrong: should use [Data(value=v)]
        _: 0.0
    )

suite "Negative Tests: SinglyLinkedRing Object Pattern Errors":

  test "object pattern Record(id) on SinglyLinkedRing[Record] should not compile":
    type Record = object
      id: int
      name: string
    check shouldNotCompile (
      var ring = initSinglyLinkedRing[Record]()
      ring.add(Record(id: 1, name: "test"))
      match ring:
        Record(id): id  # Wrong: should use [Record(id)]
        _: 0
    )

suite "Negative Tests: DoublyLinkedRing Object Pattern Errors":

  test "nested object pattern Container(Item(val)) on DoublyLinkedRing[Container] should not compile":
    type
      Item = object
        val: int
      Container = object
        item: Item
    check shouldNotCompile (
      var ring = initDoublyLinkedRing[Container]()
      ring.add(Container(item: Item(val: 100)))
      match ring:
        Container(Item(val)): val  # Wrong: should use [Container(Item(val))]
        _: 0
    )

# ============================================================================
# SUITE 7: LinkedList - Table Pattern Errors
# ============================================================================

suite "Negative Tests: SinglyLinkedList Table Pattern Errors":

  test "table pattern {k: v} on SinglyLinkedList[Table] should not compile":
    check shouldNotCompile (
      var list = initSinglyLinkedList[Table[string, int]]()
      list.add({"x": 10}.toTable)
      match list:
        {"x": val}: val  # Wrong: should use [{"x": val}]
        _: 0
    )

suite "Negative Tests: DoublyLinkedList Table Pattern Errors":

  test "table pattern {key: value} on DoublyLinkedList[int] should not compile":
    check shouldNotCompile (
      var list = initDoublyLinkedList[int]()
      list.add(42)
      match list:
        {"num": n}: n  # Wrong: type mismatch and should use []
        _: 0
    )

suite "Negative Tests: SinglyLinkedRing Table Pattern Errors":

  test "spread table pattern {a: x, **rest} on SinglyLinkedRing[Table] should not compile":
    check shouldNotCompile (
      var ring = initSinglyLinkedRing[Table[string, string]]()
      ring.add({"a": "1", "b": "2"}.toTable)
      match ring:
        {"a": val, **rest}: val  # Wrong: should use [{"a": val, **rest}]
        _: ""
    )

suite "Negative Tests: DoublyLinkedRing Table Pattern Errors":

  test "empty table pattern {} on DoublyLinkedRing[Table] should not compile":
    check shouldNotCompile (
      var ring = initDoublyLinkedRing[Table[int, int]]()
      ring.add({1: 100}.toTable)
      match ring:
        {}: "empty"  # Wrong: should use [{}]
        _: ""
    )

# ============================================================================
# SUITE 8: LinkedList - Set Pattern Errors
# ============================================================================

suite "Negative Tests: SinglyLinkedList Set Pattern Errors":

  test "set pattern {A, B} on SinglyLinkedList[set[Letter]] should not compile":
    type Letter = enum
      A, B, C
    check shouldNotCompile (
      var list = initSinglyLinkedList[set[Letter]]()
      list.add({A, B})
      match list:
        {A, B}: "has A and B"  # Wrong: should use [{A, B}]
        _: ""
    )

suite "Negative Tests: DoublyLinkedList Set Pattern Errors":

  test "set pattern {1i8, 2i8} on DoublyLinkedList[set[int8]] should not compile":
    check shouldNotCompile (
      var list = initDoublyLinkedList[set[int8]]()
      list.add({1i8, 2i8, 3i8})
      match list:
        {1i8, 2i8}: "has 1 and 2"  # Wrong: should use [{1i8, 2i8}]
        _: ""
    )

suite "Negative Tests: SinglyLinkedRing Set Pattern Errors":

  test "single element set pattern {x} on SinglyLinkedRing[set[char]] should not compile":
    check shouldNotCompile (
      var ring = initSinglyLinkedRing[set[char]]()
      ring.add({'x', 'y', 'z'})
      match ring:
        {'x'}: "has x"  # Wrong: should use [{'x'}]
        _: ""
    )

suite "Negative Tests: DoublyLinkedRing Set Pattern Errors":

  test "empty set pattern {} on DoublyLinkedRing[set[bool]] should not compile":
    check shouldNotCompile (
      var ring = initDoublyLinkedRing[set[bool]]()
      ring.add({true})
      match ring:
        {}: "empty"  # Wrong: should use [{}]
        _: ""
    )

# ============================================================================
# SUITE 9: Element Type Mismatches in Sequence Patterns
# ============================================================================

suite "Negative Tests: Deque Element Type Mismatches":

  test "string literal pattern in Deque[int] should not compile":
    check shouldNotCompile (
      var dq = initDeque[int]()
      dq.addLast(42)
      match dq:
        ["hello"]: 1  # Wrong: string literal for int element
        _: 0
    )

  test "int literal pattern in Deque[string] should not compile":
    check shouldNotCompile (
      var dq = initDeque[string]()
      dq.addLast("test")
      match dq:
        [42]: 1  # Wrong: int literal for string element
        _: 0
    )

suite "Negative Tests: LinkedList Element Type Mismatches":

  test "float literal pattern in SinglyLinkedList[int] should not compile":
    check shouldNotCompile (
      var list = initSinglyLinkedList[int]()
      list.add(10)
      match list:
        [3.14]: 1  # Wrong: float literal for int element
        _: 0
    )

  test "bool literal pattern in DoublyLinkedList[string] should not compile":
    check shouldNotCompile (
      var list = initDoublyLinkedList[string]()
      list.add("true")
      match list:
        [true]: "yes"  # Wrong: bool literal for string element
        _: ""
    )

  test "char literal pattern in SinglyLinkedRing[int] should not compile":
    check shouldNotCompile (
      var ring = initSinglyLinkedRing[int]()
      ring.add(65)
      match ring:
        ['A']: "letter A"  # Wrong: char literal for int element
        _: ""
    )

  test "wrong object type in DoublyLinkedRing[Point] should not compile":
    type
      Point = object
        x, y: int
      Circle = object
        radius: int
    check shouldNotCompile (
      var ring = initDoublyLinkedRing[Point]()
      ring.add(Point(x: 1, y: 2))
      match ring:
        [Circle(radius)]: radius  # Wrong: Circle pattern for Point element
        _: 0
    )
